# SSTable Design Document

This document outlines the design of the SSTable (Sorted String Table) format for the Sepia project, reflecting the current implementation.

## 1. Overall File Structure

An SSTable file is composed of a sequence of blocks, ordered as follows:

1.  **Data Blocks:** Contains the actual key-value pairs, sorted by key. Each data block is individually compressed and prefixed with a compression type byte.
2.  **Filter Block (Bloom Filter):** Contains a Bloom filter built from all keys in the SSTable to allow for fast, probabilistic non-existence checks. This block is written as a binary blob, typically generated by a Bloom filter library.
3.  **Index Block:** Contains a sparse index of the Data Blocks to allow for efficient seeking to the approximate location of a key. This block is currently uncompressed.
4.  **Footer:** A fixed-size block (48 bytes) at the end of the file containing offsets to other blocks, metadata, a magic number, and a checksum.

```
+-----------------------------+
| Data Block 1 (Prefixed)     |
+-----------------------------+
| Data Block 2 (Prefixed)     |
+-----------------------------+
|             ...             |
+-----------------------------+
| Data Block N (Prefixed)     |
+-----------------------------+
| Filter Block (Bloom Filter) |
+-----------------------------+
| Index Block                 |
+-----------------------------+
| Footer (48 bytes)           |
+-----------------------------+
```

## 2. Data Block

Data blocks store the key-value pairs.

*   **Structure:**
    1.  `Compression Type (1 byte)`: A single byte indicating the compression algorithm used for the `Compressed Data` part.
        *   `0x00` (from `sepia.CompressionTypeNone`): No compression.
        *   `0x01` (from `sepia.CompressionTypeSnappy`): Snappy compression.
    2.  `Compressed Data (variable size)`: The Snappy-compressed (or uncompressed if type is `0x00`) sequence of key-value entries.

*   **Entry Format (within the decompressed data):** Key-value pairs are stored contiguously. Each entry follows this format:
    *   `key_length (varint)`: Length of the key, encoded as a Go `uvarint`.
    *   `key (bytes)`: The key itself.
    *   `value_length (varint)`: Length of the value, encoded as a Go `uvarint`.
    *   `value (bytes)`: The value itself.

    Example (for an entry within the decompressed data):
    `0x03` (key_length=3) `0x6B6579` ("key") `0x05` (value_length=5) `0x76616C7565` ("value")

*   **Block-Level Compression:** As noted, each data block's entries are first serialized, then the resulting byte slice is compressed (e.g., using Snappy), and finally prefixed with the compression type byte.

*   **Internal Block Structure (Restart Points):**
    *   Currently not implemented. For now, a simpler block structure without restart points is used. Scanning requires decompressing the entire block.

## 3. Filter Block (Bloom Filter)

The Filter Block contains a Bloom filter built from all the keys in the SSTable.

*   **Serialization:** The Bloom filter is serialized using the `MarshalBinary` method of the `github.com/bits-and-blooms/bloom/v3` library. The reader uses `UnmarshalBinary` to reconstruct it. This format includes the filter's parameters (like m and k) and its bitset.

*   **Implementation:** The `github.com/bits-and-blooms/bloom/v3` library is used.

## 4. Index Block

The Index Block provides a sparse index over the Data Blocks. It is currently written uncompressed.

*   **Structure of an Index Entry:** Each entry in the index block maps a key to a specific data block. The format is:
    *   `key_length (varint)`: Length of the key, encoded as a Go `uvarint`.
    *   `key (bytes)`: The first key of the corresponding data block.
    *   `block_offset (uint64)`: The starting offset of the data block in the file (fixed 64-bit, Little Endian). This offset points to the `Compression Type` byte of the data block.
    *   `block_size (varint)`: The total size of the corresponding data block in bytes (encoded as a Go `uvarint`), including the compression type byte and the compressed data.
    *   `number_of_entries_in_block (varint)`: The number of key-value entries in that data block (encoded as a Go `uvarint`). This is an implementation-specific addition.

*   **Key Selection:** Keys for the sparse index are the first key of each data block.

## 5. Footer

The Footer is a fixed-size block of 48 bytes (`sepia.SSTableFooterSize`) located at the very end of the SSTable file. All integer fields are Little Endian.

*   **Contents:**

    | Field                      | Size (bytes) | Type   | Description                                                                      |
    | -------------------------- | ------------ | ------ | -------------------------------------------------------------------------------- |
    | Filter Block Offset        | 8            | uint64 | Starting offset of the Filter Block.                                             |
    | Filter Block Size          | 4            | uint32 | Size of the Filter Block in bytes.                                               |
    | Index Block Offset         | 8            | uint64 | Starting offset of the Index Block.                                              |
    | Index Block Size           | 4            | uint32 | Size of the Index Block in bytes.                                                |
    | Total Entries              | 8            | uint64 | Total number of key-value entries in the SSTable.                                |
    | SSTable Format Version     | 4            | uint32 | Version of the SSTable format (e.g., `1` from `sepia.CurrentSSTableFormatVersion`). |
    | Magic Number               | 8            | uint64 | `0x53455049415353540001` (from `sepia.MagicSepiaSSTable`). "SEPIASST" + version.   |
    | Footer Checksum (CRC32C)   | 4            | uint32 | CRC32C checksum of the preceding 44 bytes of the footer.                         |
    | **Total Size**             | **48**       |        |                                                                                  |

## 6. API Overview

The Sepia SSTable functionality is primarily accessed through two types: `SSTableWriter` and `SSTableReader`.

### SSTableWriter (`internal/storage/sepia/sstable_writer.go`)

*   **Creation:**
    ```go
    writer, err := sepia.NewSSTableWriter(filePath, opts...)
    ```
    Options (`sepia.WriterOption`) like `sepia.WithBlockSize()` and `sepia.WithBloomFilterFPRate()` can be provided.
*   **Adding Entries:**
    ```go
    err = writer.Add(key, value)
    ```
    Keys must be added in strictly increasing lexicographical order.
*   **Finalization:**
    ```go
    err = writer.Finish() // or writer.Close()
    ```
    This flushes all remaining data, writes the filter and index blocks, and finally the footer. It must be called to produce a valid SSTable.

### SSTableReader (`internal/storage/sepia/sstable_reader.go`)

*   **Opening:**
    ```go
    reader, err := sepia.NewSSTableReader(filePath)
    ```
    This opens the file, reads the footer, filter block, and index block into memory.
*   **Retrieving Entries:**
    ```go
    value, found, err := reader.Get(key)
    ```
*   **Closing:**
    ```go
    err = reader.Close()
    ```
    This releases the file handle.

This design provides a foundational structure for SSTables in Sepia. Further details and potential optimizations (like prefix compression for keys in data blocks, or more advanced indexing strategies) can be explored as development progresses.
